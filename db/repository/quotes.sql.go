// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotes.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const AcceptQuote = `-- name: AcceptQuote :one
UPDATE quotes
SET status = 'accepted', updated_at = NOW()
WHERE id = $1
RETURNING id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at
`

func (q *Queries) AcceptQuote(ctx context.Context, id uuid.UUID) (*Quote, error) {
	row := q.db.QueryRow(ctx, AcceptQuote, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const CountQuotesByCaseID = `-- name: CountQuotesByCaseID :one
SELECT COUNT(*) FROM quotes WHERE case_id = $1
`

func (q *Queries) CountQuotesByCaseID(ctx context.Context, caseID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountQuotesByCaseID, caseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountQuotesByLawyerID = `-- name: CountQuotesByLawyerID :one
SELECT COUNT(*) FROM quotes
WHERE lawyer_id = $1
  AND ($2::VARCHAR IS NULL OR $2::VARCHAR = '' OR status = $2)
`

type CountQuotesByLawyerIDParams struct {
	LawyerID uuid.UUID `json:"lawyer_id"`
	Column2  string    `json:"column_2"`
}

func (q *Queries) CountQuotesByLawyerID(ctx context.Context, arg *CountQuotesByLawyerIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, CountQuotesByLawyerID, arg.LawyerID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateQuote = `-- name: CreateQuote :one
INSERT INTO quotes (case_id, lawyer_id, amount, expected_days, note, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at
`

type CreateQuoteParams struct {
	CaseID       uuid.UUID      `json:"case_id"`
	LawyerID     uuid.UUID      `json:"lawyer_id"`
	Amount       pgtype.Numeric `json:"amount"`
	ExpectedDays int32          `json:"expected_days"`
	Note         pgtype.Text    `json:"note"`
	Status       string         `json:"status"`
}

func (q *Queries) CreateQuote(ctx context.Context, arg *CreateQuoteParams) (*Quote, error) {
	row := q.db.QueryRow(ctx, CreateQuote,
		arg.CaseID,
		arg.LawyerID,
		arg.Amount,
		arg.ExpectedDays,
		arg.Note,
		arg.Status,
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetAcceptedQuoteByCaseID = `-- name: GetAcceptedQuoteByCaseID :one
SELECT id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at FROM quotes 
WHERE case_id = $1 AND status = 'accepted'
LIMIT 1
`

func (q *Queries) GetAcceptedQuoteByCaseID(ctx context.Context, caseID uuid.UUID) (*Quote, error) {
	row := q.db.QueryRow(ctx, GetAcceptedQuoteByCaseID, caseID)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetQuoteByCaseAndLawyer = `-- name: GetQuoteByCaseAndLawyer :one
SELECT id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at FROM quotes 
WHERE case_id = $1 AND lawyer_id = $2
`

type GetQuoteByCaseAndLawyerParams struct {
	CaseID   uuid.UUID `json:"case_id"`
	LawyerID uuid.UUID `json:"lawyer_id"`
}

func (q *Queries) GetQuoteByCaseAndLawyer(ctx context.Context, arg *GetQuoteByCaseAndLawyerParams) (*Quote, error) {
	row := q.db.QueryRow(ctx, GetQuoteByCaseAndLawyer, arg.CaseID, arg.LawyerID)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetQuoteByID = `-- name: GetQuoteByID :one
SELECT id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at FROM quotes WHERE id = $1
`

func (q *Queries) GetQuoteByID(ctx context.Context, id uuid.UUID) (*Quote, error) {
	row := q.db.QueryRow(ctx, GetQuoteByID, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetQuotesByCaseID = `-- name: GetQuotesByCaseID :many
SELECT q.id, q.case_id, q.lawyer_id, q.amount, q.expected_days, q.note, q.status, q.created_at, q.updated_at, u.name as lawyer_name, u.jurisdiction as lawyer_jurisdiction
FROM quotes q
JOIN users u ON q.lawyer_id = u.id
WHERE q.case_id = $1
ORDER BY q.created_at ASC
`

type GetQuotesByCaseIDRow struct {
	ID                 uuid.UUID          `json:"id"`
	CaseID             uuid.UUID          `json:"case_id"`
	LawyerID           uuid.UUID          `json:"lawyer_id"`
	Amount             pgtype.Numeric     `json:"amount"`
	ExpectedDays       int32              `json:"expected_days"`
	Note               pgtype.Text        `json:"note"`
	Status             string             `json:"status"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	LawyerName         pgtype.Text        `json:"lawyer_name"`
	LawyerJurisdiction pgtype.Text        `json:"lawyer_jurisdiction"`
}

func (q *Queries) GetQuotesByCaseID(ctx context.Context, caseID uuid.UUID) ([]*GetQuotesByCaseIDRow, error) {
	rows, err := q.db.Query(ctx, GetQuotesByCaseID, caseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetQuotesByCaseIDRow{}
	for rows.Next() {
		var i GetQuotesByCaseIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.LawyerID,
			&i.Amount,
			&i.ExpectedDays,
			&i.Note,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LawyerName,
			&i.LawyerJurisdiction,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetQuotesByLawyerID = `-- name: GetQuotesByLawyerID :many
SELECT q.id, q.case_id, q.lawyer_id, q.amount, q.expected_days, q.note, q.status, q.created_at, q.updated_at, c.title as case_title, c.category as case_category, c.status as case_status
FROM quotes q
JOIN cases c ON q.case_id = c.id
WHERE q.lawyer_id = $1
  AND ($2::VARCHAR IS NULL OR $2::VARCHAR = '' OR q.status = $2)
ORDER BY q.created_at DESC
LIMIT $3 OFFSET $4
`

type GetQuotesByLawyerIDParams struct {
	LawyerID uuid.UUID `json:"lawyer_id"`
	Column2  string    `json:"column_2"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

type GetQuotesByLawyerIDRow struct {
	ID           uuid.UUID          `json:"id"`
	CaseID       uuid.UUID          `json:"case_id"`
	LawyerID     uuid.UUID          `json:"lawyer_id"`
	Amount       pgtype.Numeric     `json:"amount"`
	ExpectedDays int32              `json:"expected_days"`
	Note         pgtype.Text        `json:"note"`
	Status       string             `json:"status"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CaseTitle    string             `json:"case_title"`
	CaseCategory string             `json:"case_category"`
	CaseStatus   string             `json:"case_status"`
}

func (q *Queries) GetQuotesByLawyerID(ctx context.Context, arg *GetQuotesByLawyerIDParams) ([]*GetQuotesByLawyerIDRow, error) {
	rows, err := q.db.Query(ctx, GetQuotesByLawyerID,
		arg.LawyerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetQuotesByLawyerIDRow{}
	for rows.Next() {
		var i GetQuotesByLawyerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.LawyerID,
			&i.Amount,
			&i.ExpectedDays,
			&i.Note,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CaseTitle,
			&i.CaseCategory,
			&i.CaseStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RejectOtherQuotes = `-- name: RejectOtherQuotes :many
UPDATE quotes
SET status = 'rejected', updated_at = NOW()
WHERE case_id = $1 AND id != $2 AND status = 'proposed'
RETURNING id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at
`

type RejectOtherQuotesParams struct {
	CaseID uuid.UUID `json:"case_id"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) RejectOtherQuotes(ctx context.Context, arg *RejectOtherQuotesParams) ([]*Quote, error) {
	rows, err := q.db.Query(ctx, RejectOtherQuotes, arg.CaseID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Quote{}
	for rows.Next() {
		var i Quote
		if err := rows.Scan(
			&i.ID,
			&i.CaseID,
			&i.LawyerID,
			&i.Amount,
			&i.ExpectedDays,
			&i.Note,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateQuote = `-- name: UpdateQuote :one
UPDATE quotes
SET amount = $2, expected_days = $3, note = $4, status = 'proposed', updated_at = NOW()
WHERE id = $1 AND status != 'accepted'
RETURNING id, case_id, lawyer_id, amount, expected_days, note, status, created_at, updated_at
`

type UpdateQuoteParams struct {
	ID           uuid.UUID      `json:"id"`
	Amount       pgtype.Numeric `json:"amount"`
	ExpectedDays int32          `json:"expected_days"`
	Note         pgtype.Text    `json:"note"`
}

func (q *Queries) UpdateQuote(ctx context.Context, arg *UpdateQuoteParams) (*Quote, error) {
	row := q.db.QueryRow(ctx, UpdateQuote,
		arg.ID,
		arg.Amount,
		arg.ExpectedDays,
		arg.Note,
	)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.CaseID,
		&i.LawyerID,
		&i.Amount,
		&i.ExpectedDays,
		&i.Note,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
